options {
	STATIC = false;
	JDK_VERSION = "1.7";
	ERROR_REPORTING = true;
	UNICODE_INPUT = true;
	DEBUG_LOOKAHEAD = false;
	DEBUG_PARSER = false;
//	DEBUG_LOOKAHEAD = true;
//	DEBUG_PARSER = true;
	DEBUG_TOKEN_MANAGER = false;

	// FIXME: remove when done
//	FORCE_LA_CHECK = true;
}

PARSER_BEGIN(Parser)
package net.sandius.rembulan.parser;

import net.sandius.rembulan.parser.ast.*;
import java.util.*;

import static java.util.Collections.*;

public class Parser {

	private static List<BodyStatement> none() {
		return Collections.<BodyStatement>emptyList();
	}

	private static List<BodyStatement> one(BodyStatement v) {
		return Collections.<BodyStatement>singletonList(v);
	}

	private static List<BodyStatement> pair(BodyStatement u, BodyStatement v) {
		List<BodyStatement> l = new ArrayList<BodyStatement>();
		l.add(u);
		l.add(v);
		return Collections.<BodyStatement>unmodifiableList(l);
	}

	private static LValueExpr toLValueExpr(List<Name> names) {
		LValueExpr lv = null;
		for (Name n : names) {
			lv = lv != null ? new FieldRef(lv, new LiteralExpr(StringLiteral.fromName(n))) : new Var(n);
		}
		return lv;
	}

}

PARSER_END(Parser)

/* Whitespace */
SKIP :
{
	" " | "\t" | "\n" | "\r" | "\f"
}


/* Comments */

// TODO: multi-line comments, nested comments

//MORE :
//{
//  "%" : IN_LINE_COMMENT
//}

SPECIAL_TOKEN :
{
	<LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

/* Keywords */
TOKEN :
{
	<AND: "and">
|	<BREAK: "break">
|	<DO: "do">
|	<ELSE: "else">
|	<ELSEIF: "elseif">
|	<END: "end">
|	<FALSE: "false">
|	<FOR: "for">
|	<FUNCTION: "function">
|	<GOTO: "goto">
|	<IF: "if">
|	<IN: "in">
|	<LOCAL: "local">
|	<NIL: "nil">
|	<NOT: "not">
|	<OR: "or">
|	<REPEAT: "repeat">
|	<RETURN: "return">
|	<THEN: "then">
|	<TRUE: "true">
|	<UNTIL: "until">
|	<WHILE: "while">
}

/* Literals */
TOKEN :
{
	<NAME: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}

/* Numerals and strings */
TOKEN :
{
	// Numerals
	<NUMERAL: <DEC_NUMERAL> | <HEX_NUMERAL>>

|	<#DECDIGIT: ["0"-"9"]>
|	<#HEXDIGIT: ["0"-"9", "a"-"f", "A"-"F"]>
|	<#SIGN: ["+","-"]>
|	<#DECEXP: ["e","E"]>
|	<#HEX: "0" ["x","X"]>
|	<#HEXEXP: ["p","P"]>

|	<#DEC_NUMERAL: (<DECDIGIT>)+ ("." (<DECDIGIT>)*)? (<DECEXP> (<SIGN>)? (<DECDIGIT>)+)?>
|	<#HEX_NUMERAL: <HEX> (<HEXDIGIT>)+ ("." (<HEXDIGIT>)*)? (<HEXEXP> (<SIGN>)? (<DECDIGIT>)+)?>

	// String literals
|	<LITERAL_STRING: <DOUBLE_QUOTED_STRING> | <SINGLE_QUOTED_STRING>>
|	<#DOUBLE_QUOTED_STRING: "\"" (<ESCAPED> | ~["\\","\""] | "\\\"")* "\"">
|	<#SINGLE_QUOTED_STRING: "'" (<ESCAPED> | ~["\\","'"] | "\\'")* "'">

|	<#ESCAPED: <HEXCHAR> | <DECCHAR> | <UNICODE> | <CHAR>>
|	<#HEXCHAR: "\\" "x" (<HEXDIGIT>){2}>
|	<#DECCHAR: "\\" (<DECDIGIT>){1,3}>
|	<#UNICODE: "\\" "u" "{" (<HEXDIGIT>)+ "}">
|	<#CHAR: "\\" ("a" | "b" | "f" | "n" | "r" | "t" | "v") >
|	<#LF: ("\n" | "\r" | "\r\n") >

// TODO: the \z escape sequence
// TODO: long brackets

}

/* Other tokens */
TOKEN :
{
	// operators
	<PLUS: "+">
|	<MINUS: "-">
|	<MUL: "*">
|	<DIV: "/">
|	<MOD: "%">
|	<POW: "^">
|	<LEN: "#">
|	<BAND: "&">
|	<BNOT: "~">  // FIXME: this is a BNOT and BXOR
|	<BOR: "|">
|	<SHL: "<<">
|	<SHR: ">>">
|	<IDIV: "//">
|	<DBL_DOT: "..">  // string concatenation

	// comparison operators
|	<EQ: "==">
|	<NEQ: "~=">
|	<LE: "<=">
|	<GE: ">=">
|	<LT: "<">
|	<GT: ">">

	// other
|	<ASSIGN: "=">
|	<PAREN_OPEN: "(">
|	<PAREN_CLOSE: ")">
|	<CURLY_OPEN: "{">
|	<CURLY_CLOSE: "}">
|	<SQUARE_OPEN: "[">
|	<SQUARE_CLOSE: "]">
|	<DOUBLE_COLON: "::">
|	<SEMICOLON: ";">
|	<COLON: ":">
|	<COMMA: ",">
|	<DOT: ".">
|	<VARARGS: "...">
}

Name Name() :
{
	Token t;
}
{
    t=<NAME>  { return Name.fromString(t.image); }
}

StringLiteral StringLiteral() :
{
	Token t;
}
{
	t=<LITERAL_STRING>  { return StringLiteral.fromString(t.image); }
}

Numeral Numeral() :
{
	Token t;
}
{
	t=<NUMERAL>  { return Numeral.fromString(t.image); }
}

// FIXME: remove when done?
void Eof() :
{ }
{
	<EOF>
}

Chunk Chunk() :
{
	Block b;
}
{
	b=Block() <EOF> { return new Chunk(b); }
}

Block Block() :
{
	List<BodyStatement> ss;
	List<BodyStatement> stats = new ArrayList<BodyStatement>();
	ReturnStatement ret = null;
}
{
	(ss=BodyStatement() { stats.addAll(ss); })* (ret=ReturnStatement())? { return new Block(Collections.unmodifiableList(stats), ret); }
}

List<BodyStatement> BodyStatement() :
{
	Name n, m = null;
	Expr e, f;
	Expr g = null;
	Block b;

	FunctionLiteral fb;

	List<LValueExpr> vars;
	List<Name> names = new ArrayList<Name>();
	List<Expr> exprs = Collections.emptyList();

	BodyStatement s;
	List<BodyStatement> ss = new ArrayList<BodyStatement>();
}
{
	<SEMICOLON>  { return none(); }
|	s=AssignOrCall()  { return one(s); }
|   <DOUBLE_COLON> n=Name() <DOUBLE_COLON> { return one(new LabelStatement(n)); }
|	<BREAK>  { return one(new BreakStatement()); }
|	<GOTO> n=Name()  { return one(new GotoStatement(n)); }
|	<DO> b=Block() <END>  { return one(new DoStatement(b)); }
|	<WHILE> e=Expr() <DO> b=Block() <END>  { return one(new WhileStatement(e, b)); }
|	<REPEAT> b=Block() <UNTIL> e=Expr()  { return one(new RepeatUntilStatement(e, b)); }
|	s=IfStatement()  { return one(s); }
|	LOOKAHEAD(3) <FOR> n=Name() <ASSIGN> e=Expr() <COMMA> f=Expr() (<COMMA> g=Expr())? <DO> b=Block() <END>  { return one(new NumericForStatement(n, e, f, g, b)); }
|	<FOR> names=NameList() <IN> exprs=ExprList() <DO> b=Block() <END>  { return one(new GenericForStatement(names, exprs, b)); }

|	<FUNCTION> n=Name() { names.add(n); } (<DOT> n=Name() { names.add(n); })* (<COLON> m=Name())? fb=FunctionBody()  {
		if (m != null) {
			// defining a method: change fb's signature by prepending a "self" field
			FunctionLiteral.Params params = fb.params();
			List<Name> ps = new ArrayList<Name>();
			ps.add(Name.fromString("self"));
			ps.addAll(fb.params().names());
			ps = Collections.unmodifiableList(ps);
			params = new FunctionLiteral.Params(ps, params.isVararg());
			fb = new FunctionLiteral(params, fb.block());

			// append method name to the overall name list
			names.add(m);
		}
		return one(new AssignStatement(Collections.<LValueExpr>singletonList(toLValueExpr(names)), Collections.<Expr>singletonList(new FunctionDefExpr(fb))));
	}

|	LOOKAHEAD(2) <LOCAL> <FUNCTION> n=Name() fb=FunctionBody()  {
		return pair(
			LocalDeclStatement.singleton(n),
			new AssignStatement(Collections.<LValueExpr>singletonList(new Var(n)), Collections.<Expr>singletonList(new FunctionDefExpr(fb)))
		);
	}

|	<LOCAL> names=NameList() (<ASSIGN> exprs=ExprList())?  {
		return one(LocalDeclStatement.of(names, exprs));
	}
}

Expr Expr() :
{
	Operator.Unary uop;
	Operator.Binary bop;
	Expr e;

	ExprBuilder bld = new ExprBuilder();
}
{
	(uop=UnOp() { bld.add(uop); })* e=SimpleExpr() { bld.add(e); }
			(LOOKAHEAD(2) bop=BinOp() { bld.add(bop); } (uop=UnOp() { bld.add(uop); })* e=SimpleExpr() { bld.add(e); })*
			{ return bld.build(); }
}

Expr SimpleExpr() :
{
	Token t;
	Literal l;
	Expr e;
	FunctionLiteral fn;
}
{
	<NIL>    { return new LiteralExpr(NilLiteral.INSTANCE); }
|	<FALSE>  { return new LiteralExpr(BooleanLiteral.FALSE); }
|	<TRUE>   { return new LiteralExpr(BooleanLiteral.TRUE); }
|	l=Numeral()  { return new LiteralExpr(l); }
|	l=StringLiteral()  {return new LiteralExpr(l); }
|	<VARARGS>  { return new VarargsExpr(); }
|	<FUNCTION> fn=FunctionBody()  { return new FunctionDefExpr(fn); }
|	e=PrefixExpr()  { return e; }
|	e=TableConstructor()  { return e; }
}

Expr PrefixExpr() :
{
	Expr e;
	PostfixOp op;
}
{
	e=VarExpr() (LOOKAHEAD(2) op=__PostfixOp() { e=op.on(e); })*  { return e; }
}

Expr VarExpr() :
{
	LValueExpr lv;
	Name n;
	Expr e;
}
{
	n=Name()  { return new Var(n); }
|	<PAREN_OPEN> e=Expr() <PAREN_CLOSE>  { return e; }
}

PostfixOp __PostfixOp() :
{
	PostfixOp op;
}
{
	op=__FieldAccessOp()  { return op; }
|	op=__InvokeOp()  { return op; }
}

BodyStatement AssignOrCall() :
{
	Expr e;
	AssignRest ar;
}
{
	e=PrefixExpr()
	(ar=AssignOrCallRest()
		{
			if (e instanceof LValueExpr) {
				return ar.prepend((LValueExpr) e);
			}
			else {
				throw new ParseException("lvalue expected");
			}
		}
	)?

	{
		if (e instanceof CallExpr) {
			return new CallStatement((CallExpr) e);
		}
		else {
			throw new ParseException("function call expected");
		}
	}
}

AssignRest AssignOrCallRest() :
{
	LValueExpr v;
	List<LValueExpr> vs = new ArrayList<LValueExpr>();
	List<Expr> es;
}
{
	// single assignment
	<ASSIGN> es=ExprList()  { return new AssignRest(es); }

	// multiple assignments
|	(<COMMA> v=LValue() { vs.add(v); })+ <ASSIGN> es=ExprList()  { return new AssignRest(Collections.unmodifiableList(vs), es); }
}

LValueExpr LValue() :
{
	Name n;
	Expr e;
	FieldAccessOp fa;
}
{
	LOOKAHEAD(2) n=Name()  { return new Var(n); }
|	e=PrefixExpr() fa=__FieldAccessOp()  { return fa.on(e); }
}

List<Expr> Args() :
{
	Expr e;
	Literal l;
	List<Expr> es = Collections.emptyList();
}
{
	<PAREN_OPEN> (es=ExprList())? <PAREN_CLOSE>  { return es; }
|	e=TableConstructor()  { return Collections.<Expr>singletonList(e); }
|	l=StringLiteral()  { return Collections.<Expr>singletonList(new LiteralExpr(l)); }
}

IfStatement IfStatement() :
{
	Expr e;
	Block b;
	ConditionalBlock ift;
	ArrayList<ConditionalBlock> elifs = new ArrayList<ConditionalBlock>();
	Block els = null;
}
{
	<IF> e=Expr() <THEN> b=Block() { ift = new ConditionalBlock(e, b); }
			(<ELSEIF> e=Expr() <THEN> b=Block() { elifs.add(new ConditionalBlock(e, b)); } )*
			(<ELSE> els=Block())?
			<END>  { return new IfStatement(ift, elifs, els); }
}

/*
	retstat ::= return [explist] [‘;’]
*/
ReturnStatement ReturnStatement() :
{
	List<Expr> exprs = Collections.emptyList();
}
{
	<RETURN> (exprs=ExprList())? (<SEMICOLON>)? { return new ReturnStatement(exprs); }
}

FieldAccessOp __FieldAccessOp() :
{
	Expr e;
	Name n;
}
{
	<SQUARE_OPEN> e=Expr() <SQUARE_CLOSE>  { return new FieldAccessOp(e); }
|	<DOT> n=Name()  { return new FieldAccessOp(new LiteralExpr(StringLiteral.fromName(n))); }
}

InvokeOp __InvokeOp() :
{
	Name n;
	List<Expr> params;
}
{	params=Args()  { return new InvokeOp(params, null); }
|	<COLON> n=Name() params=Args()  { return new InvokeOp(params, n); }
}


List<Name> NameList() :
{
	Name n;
	ArrayList<Name> ns = new ArrayList<Name>();
}
{
	n=Name() { ns.add(n); } (LOOKAHEAD(2) <COMMA> n=Name() { ns.add(n); })*  { return Collections.unmodifiableList(ns); }
}

List<Expr> ExprList() :
{
	Expr e;
	ArrayList<Expr> es = new ArrayList<Expr>();
}
{
	e=Expr() { es.add(e); } (<COMMA> e=Expr() { es.add(e); })* { return Collections.unmodifiableList(es); }
}

FunctionLiteral FunctionBody() :
{
	FunctionLiteral.Params params = FunctionLiteral.Params.empty();
	Block block;
}
{
	<PAREN_OPEN> (params=FunctionParams())? <PAREN_CLOSE> block=Block() <END>  { return new FunctionLiteral(params, block); }
}

FunctionLiteral.Params FunctionParams() :
{
	List<Name> params = Collections.emptyList();
	boolean vararg = false;
}
{
	params=NameList() (<COMMA> <VARARGS> { vararg = true; })?  { return new FunctionLiteral.Params(params, vararg); }
|	<VARARGS>  { return new FunctionLiteral.Params(params, true); }
}

TableConstructorExpr TableConstructor() :
{
	TableConstructorExpr.FieldInitialiser fi;
	List<TableConstructorExpr.FieldInitialiser> fields = new ArrayList<TableConstructorExpr.FieldInitialiser>();
}
{
	<CURLY_OPEN> (fields=FieldInitialiserList())? <CURLY_CLOSE>  { return new TableConstructorExpr(fields); }
}

void FieldSeparator() :
{ }
{
	<COMMA>
|	<SEMICOLON>
}

List<TableConstructorExpr.FieldInitialiser> FieldInitialiserList() :
{
	TableConstructorExpr.FieldInitialiser f;
	ArrayList<TableConstructorExpr.FieldInitialiser> fs = new ArrayList<TableConstructorExpr.FieldInitialiser>();
}
{
	f=FieldInitialiser() { fs.add(f); } (LOOKAHEAD(2) FieldSeparator() f=FieldInitialiser() { fs.add(f); })* (FieldSeparator())?  { return Collections.unmodifiableList(fs); }
}

TableConstructorExpr.FieldInitialiser FieldInitialiser() :
{
	Expr e, f;
	Name n;
}
{
	<SQUARE_OPEN> e=Expr() <SQUARE_CLOSE> <ASSIGN> f=Expr()  { return new TableConstructorExpr.FieldInitialiser(e, f); }
|	LOOKAHEAD(2) n=Name() <ASSIGN> e=Expr()  { return new TableConstructorExpr.FieldInitialiser(new LiteralExpr(StringLiteral.fromName(n)), e); }
|	e=Expr()  { return new TableConstructorExpr.FieldInitialiser(null, e); }
}

/*
	binop ::=  ‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘//’ | ‘^’ | ‘%’ |
		 ‘&’ | ‘~’ | ‘|’ | ‘>>’ | ‘<<’ | ‘..’ |
		 ‘<’ | ‘<=’ | ‘>’ | ‘>=’ | ‘==’ | ‘~=’ |
		 and | or
*/
Operator.Binary BinOp() :
{ }
{
	<PLUS>     { return Operator.Binary.ADD; }
|	<MINUS>    { return Operator.Binary.SUB; }
|	<MUL>      { return Operator.Binary.MUL; }
|	<DIV>      { return Operator.Binary.DIV; }
|	<IDIV>     { return Operator.Binary.IDIV; }
|	<POW>      { return Operator.Binary.POW; }
|	<MOD>      { return Operator.Binary.MOD; }
|	<BAND>     { return Operator.Binary.BAND; }
|	<BNOT>     { return Operator.Binary.BXOR; }
|	<BOR>      { return Operator.Binary.BOR; }
|	<SHR>      { return Operator.Binary.SHR; }
|	<SHL>      { return Operator.Binary.SHL; }
|	<DBL_DOT>  { return Operator.Binary.CONCAT; }
|	<LT>       { return Operator.Binary.LT; }
|	<LE>       { return Operator.Binary.LE; }
|	<GT>       { return Operator.Binary.GT; }
|	<GE>       { return Operator.Binary.GE; }
|	<EQ>       { return Operator.Binary.EQ; }
|	<NEQ>      { return Operator.Binary.NEQ; }
|	<AND>      { return Operator.Binary.AND; }
|	<OR>       { return Operator.Binary.OR; }
}

/*
	unop ::= ‘-’ | not | ‘#’ | ‘~’
*/
Operator.Unary UnOp() :
{ }
{
	<MINUS>  { return Operator.Unary.UNM; }
|	<NOT>    { return Operator.Unary.NOT; }
|	<LEN>    { return Operator.Unary.LEN; }
|	<BNOT>   { return Operator.Unary.BNOT; }
}
